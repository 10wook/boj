N, M = map(int,input().split())
B = []
for i in range(N):
    B.append(list(map(int,input().split())))
    
###
#모든 경우의 수의 회전을 찾아봐야 할듯
# 모든 블록 경우의 수 = 23개일듯
#블록의 형태를 이중 어레이 형태로 리스트에 담아두고, 칸수 옮기면서 확인해보면 될듯
#1 막대기 부터 시작합시다. 

blocks = [
[[0,0],[0,1],[0,2],[0,3]], #눕힌 막대기
[[0,0],[1,0],[2,0],[3,0]], #세운 막대기

[[0,0],[1,0],[0,1],[1,1]], # 네모

[[0,0],[1,0],[2,0],[0,1]], #위가 길쭉한 ㄴ
[[0,0],[1,0],[1,1],[1,2]], # /--- 가로가 긴 이 모양
[[2,0],[2,1],[1,1],[0,1]], # 세로가 긴 ㄱ
[[0,0],[0,1],[0,2],[1,2]], # ___| 이거임

[[0,0],[0,1],[1,1],[2,1]], # _| 이거임 => 세로가 긴 버전
[[0,0],[1,0],[0,1],[0,2]], # |___ 이거임 => 가로가 긴 버전
[[0,0],[1,0],[2,0],[2,1]], # |- 이거임 => 세로가 긴 버전
[[1,0],[1,1],[1,2],[0,2]], # 가로가 긴 ㄱ

[[0,0],[1,1],[0,1],[0,2]], # ㅗ
[[0,0],[1,0],[2,0],[1,1]], # ㅏ
[[0,1],[1,0],[1,1],[1,2]], # ㅜ
[[0,1],[1,0],[1,1],[2,1]], # ㅓ

[[0,1],[1,0],[1,1],[2,0]], # '-.
[[0,0],[0,1],[1,1],[1,2]], # __--

[[0,0],[1,0],[1,1],[2,1]], # .-'
[[1,0],[0,1],[1,1],[0,2]]  # --__
]


# 이제 들어갈 수 있느 확인하는 함수 + 점수 집계하는 함수 만들어야 함
def score(block:list,r:int,c:int):
    cnt = 0 
    for i in block:
        if r+i[0] >= N or c+i[1] >= M: # 가능 조건 확인,
            return -1
        else :
            cnt += B[r+i[0]][c+i[1]] # 점수 집계
    return cnt
    
    
#모든 블록 모든 자리에 대해서 수행해야함
answer = 0
for i in range(N):
    for j in range(M):
        for block in blocks:
            answer = max(score(block,i,j),answer)
        
print(answer)